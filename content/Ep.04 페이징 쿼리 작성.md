# 페이징 쿼리 작성

## 페이징 쿼리
- 쿼리를 통해 전체 데이터중 원하는 데이터를 부분적으로 나눠서 조회 및 처리하는 방법
- 한번에 처리해야 하는 데이터의 양이 줄어들어 DB서버와 애플리케이션 서버의 리소스 사용을 보다 효율적으로 만듦
- 애플리케이션 서버에서 처리 시간도 단축되어, 서비스 이용자들에게 더 빠른 응당 시간, 더 나은 서비스 경험 제공

## 페이징 쿼리 구현 일반적인 방법
- 일반적으로 LIMIT & OFFSET 구문을 사용하는 경우가 많다
- 이 방식은 DBMS에 많은 부하를 발생시킬 수 있다.
  - OFFSET은 지정된 위치까지 데이터를 순차적으로 읽어야 하므로, 불필요한 데이터 읽기가 발생 (OFFSET이후의 데이터를 바로 가져올 수 없다)
- 페이지 번호가 높아질수록, OFFSET 값을 늘리면서 쿼리를 실행할 수록 데이터베이스는 더욱 많은 데이터를 읽어야함
- 결과적으로 한번에 모든 데이터를 가져오는 것 보다 더 많은 데이터를 읽고 처리하게 됨

![image](https://github.com/user-attachments/assets/e8b3f876-fa31-409a-b597-cd3bf607d397)

- 500건 씩 N번 조회 -> ((1 * 500) + (2 * 500) + (3 * 500) + ... + (N * 500))

<br>

- 다른 방식으로 페이징 쿼리를 구현하는 것을 생각해 볼 필요가 있다. (OFFSET 대신 인덱스 활용)
  1. 범위 기반 방식
  2. 데이터 개수 기반 방식

## 범위 기반 방식
- 매 쿼리 실행 시 WHERE 절에서 조회 범위를 직접 지정하는 형태, LIMIT절이 사용되지 않음
- 주로 배치 작업 등에서 사용, 날짜 기간이나 숫자 범위로 나눠서 데이터 조회
  - 생성 일자 칼럼을 기준으로 하여 한달치 데이터를 일주일 단위로 나눠서 처리
  - 오토 인크리먼트 칼럼을 기준으로 하여 일정한 데이터 범위 나눠서 처리
- 쿼리에서 사용되는 조회 조건이 단순한 편이어서 여러번 쿼리를 나누어 실행하더라도 사용되는 쿼리의 형태가 동일하다

### 범위 기반 방식 예

- 숫자인 id 값을 바탕으로 범위를 나눠 데이터 조회 (5000 단위로 조회)
```
SELECT *
FROM users
WHERE id > 0 AND id <= 5000
```
- 날짜 기준으로 나눠서 조회 (일 단위로 조회)
```
SELECT *
FROM payments
WHERE finished_at >= '2022-03-01' AND finished_at < '2022-03-02'
```

<br>

- 처음부터 모든 데이터를 읽지 않고, 지정된 범위의 데이터만 빠르게 읽어들인다.
- 이 방식의 경우 해당 칼럼이 인덱스로 설정 되어있어야 한다.

## 데이터 개수 기반 방식
- 지정된 데이터 건수 만큼 데이터를 반환하는 형태
- 배치보단 주로 서비스 단에서 많이 사용되는 방식, 쿼리에서 ORDER BY & LIMIT절이 함께 사용됨
- 처음 쿼리를 실행할 때(1회차)와 그 이후 쿼리를 실행할 때(N회차) 쿼리의 형태가 달라진다
- **WHERE절에서 사용되는 조건**이 **동등 조건**인지, **범위 조건**인지 에 따라서 N회차 실행시 쿼리 형태가 달라진다

### 데이터 개수 기반 방식 - WHERE 동등 조건

![image](https://github.com/user-attachments/assets/5a9f0b4a-6260-4934-b80a-712d3873c5d0)

- 특정 user_id에 해당하는 데이터들을 페이징 한다고 가정
- ORDER BY, LIMIT절 추가, N회차 쿼리 WHERE절에 마지막 id값에 대한 조건이 들어감
- **KEY (user_id, id) -> (user_id, id) 컬럼 조합에 대해 인덱스를 생성**
  - 인덱스는 user_id를 먼저 기준으로 정렬하고, 동일한 user_id 내에서는 id를 기준으로 정렬된 구조

#### ORDER BY와 인덱스의 관계
- ORDER BY는 데이터를 정렬하는 데 추가적인 리소스를 요구. 하지만 적절한 인덱스를 사용하면 별도의 정렬 과정 없이 데이터를 반환할 수 있다.
- 인덱스를 활용한 정렬의 조건
  - ORDER BY에 사용된 컬럼들이 인덱스에 포함되어 있어야 한다.
  - 인덱스 컬럼 순서와 정렬 방향(ASC/DESC)이 쿼리와 일치해야 한다
  - WHERE 조건과 ORDER BY 조건이 함께 사용될 경우, WHERE 조건에 포함된 컬럼도 인덱스에 포함되어야 한다.

- ORDER BY의 리소스 요구
  - ORDER BY는 데이터가 정렬된 상태로 반환되도록 보장하기 위해 다음과 같은 작업을 수행
  - 정렬 작업: 데이터를 메모리(sort buffer)나 디스크에 임시로 저장하고 정렬.
  - 대량의 데이터가 있을 경우, 메모리 크기를 초과하면 디스크 I/O가 발생해 성능이 저하될 수 있다.
  - 추가 CPU 및 메모리 사용: 정렬 알고리즘 실행에 CPU와 메모리를 사용.
  - 특히, 인덱스가 없거나 비효율적인 경우, 모든 데이터를 읽고 정렬해야 하므로 비용이 더욱 증가
- 인덱스를 활용한 ORDER BY 최적화
  - 인덱스를 사용하면 데이터가 이미 정렬된 상태로 저장되므로 추가적인 정렬 작업 없이 데이터를 반환할 수 있다
  - 이 방식은 데이터베이스가 인덱스 순서대로 데이터를 읽기만 하면 되므로 **정렬 비용(filesort)**이 발생하지 않는다.
- ORDER BY가 필요한 이유

### 데이터 개수 기반 방식 - WHERE 범위 조건

![image](https://github.com/user-attachments/assets/cc0008ef-5cc2-4ee8-8550-1960067dfa46)

- ORDER BY 절에 finished_at 이 포함 된 이유
  - id 칼럼만 명시하면 WHERE 조건을 만족하는 데이터들을 읽은 후 id를 기준으로 정렬을 수행하게 됨. 그 후 지정 건수 만큼 반환
  - finished_at 를 선두에 명시함으로써 인덱스(finished_at, id) 사용하여 추가적인 정렬 작업을 하지 않고도 순차적으로 데이터를 읽어들임
  - 쿼리 성능 향상
- 범위 조건에서의 N회차 쿼리 작성

![image](https://github.com/user-attachments/assets/569c0b94-c78d-442d-bc55-078124779311)

- 앞선 동등 조건에서 처럼 id조건절만 추가한다면 데이터 누락 발생 - 문제 없는 경우도 있다. 추후 설명

![image](https://github.com/user-attachments/assets/fad67c69-94bd-485e-a57d-8a9c52f7f9bc)

- 올바른 쿼리 형태

![image](https://github.com/user-attachments/assets/f1b654a3-ef7a-49f5-b50e-2088a1ac91c9)

- 조건절이 두개가 필요함
  - 마지막 데이터와 같은 finished_at을 가지면서 id가 크거나
  - 마지막 데이터의 finished_at보다 크면서 기존 범위 finished_at의 최대값 보다 작을 때
  - 인덱스가 finished_at를 먼저 기준으로 정렬하고, 동일한 finished_at 내에서는 id를 기준으로 정렬되어 있는 걸 생각해 보면 알 수 있다.

#### 앞선 동등 조건에서 처럼 id조건절만 추가해도 문제 없는 경우

![image](https://github.com/user-attachments/assets/8aef4d5a-b33c-4377-9cd1-c8664dc117fd)

- user logs 테이블 pk id, 인덱스(created_at, id) 인 경우
- 페이먼트 테이블의 경우 finished at 컬럼은 결제 완료 시각으로 자동 증가 값인id 컬럼 값과 저장된 값들의 순서가 다르게 된다.
- 반면에 유저 로봇 테이블의 created at 컬럼과 id 컬럼의 경우에는 모두 데이터가 테이블에 저장된 순서대로 값이 증가하므로 각 컬럼에 대해 데이터 간 순서가 동일하다고 볼수 있다.
- 따라서 N회차 쿼리에서는 기존에 명시되어 있는 created at 컬럼의 시작 날짜 조건에 대해서만 조건 값을 변경해주고 아이디 컬럼에 대한 조건만 새롭게 추가해도 된다.
- 물론 시작 날짜 조건 값을 이전에 반환된 마지막 데이터의 날짜 값이 아닌 처음에 주어졌던 조건 값을 그대로 사용하더라도 그 다음 순번의 데이터들로 정상적으로 결과가 반환이 된다
- 하지만 이미 반환한 데이터들에 대해서도 불필요하게 인덱스 데이터를 스캔하며 조건을 체크하게 되므로 쿼리 처리 성능 향상을 위해 n일자 쿼리에서 CreatedAtColumn의 시작 날짜 조건 값은 반드시 이전에 반환된 마지막 데이터의 날짜 값으로 지정해줘야 한다.
