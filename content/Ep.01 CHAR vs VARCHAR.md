# CHAR vs VARCHAR

## 공통점
- 문자열 저장용 칼럼
- 최대 저장 가능 문자 길이 명시 **바이트 수 아님**
- 명시하는 숫자 값은 문자의 **최대 저장 개수**를 의미한다
  - 칼럼이 어떤 문자셋으로 정의되어 있는 지에 따라 사용하는 디스크 공간이 달라진다.
  - ex) Latin-1 문자셋 -> 고정 길이 문자셋. 10일 경우 최대 10 바이트 까지만 사용 가능하다
  - ex) UTF-8MB4 문자셋 -> 가변 길이 문자셋. 영어 알파벳일 경우 10바이트, 한글일 경우 30바이트, 이모지 일 경우 40바이트 까지 가능
 
## 차이점
- 값의 실제 크기에 관계 없이 고정된 공간 할당 여부가 다르다
  - CHAR ->  실제 저장되는 문자값의 길이와 관계 없이 설정된 크기만큼 항상 공간 할당
  - VARCHAR -> 저장되는 문자의 길이 만큼만 공간 할당
- 최대 저장 길이 차이
  - CHAR -> 255 까지
  - VARCHAR -> 16383 까지 -> 65535바이트
- 저장된 값의 길이를 따로 바이트로 관리 하는지 여부
  - CHAR 의 경우에도 가변길이 문자 셋을 사용하는 경우에는 저장 길이를 따로 관리한다
  - VARCHAR의 경우엔 항상 관리
    - 0 ~ 255 bytes 경우 -> 1바이트 공간으로 길이 관리
    - 256 ~ 65535 bytes 경우 -> 2바이트 공간으로 길이 관리

## 고정 길이 문자 셋 CHAR vs VARCHAR

![image](https://github.com/user-attachments/assets/bf1cb3a9-20e3-4cf4-aa10-59582d443273)

- 고정 길이 문자셋의 경우 쉽게 이해 가능하다

## 가변 길이 문자셋 CHAR vs VARCHAR

![image](https://github.com/user-attachments/assets/3b248cfc-385d-4efb-9a6f-57343ef61089)

- CHAR타입 칼럼이 가변 길이 문자셋으로 정의 되었을 경우엔 조금 이해가 필요하다
- 10으로 설정할 경우 최대 4바이트 X 10개의 문자 여서 40바이트 까지 빈 공백으로 예악할 수 있을 것 처럼 생각되는데, 이렇게 동작하지 않는다
- 실제로는 10으로 설정한 것을 바이트 수 기준으로 삼아서 공백을 설정한다.
  - 앞서 설명했듯이 **최대 저장 가능한 디스크 공간은 문자 길이 기준**으로 설정 되는 것과 헷갈릴 수 있으니 주의하자
  - 따라서 사진의 case1은 공백이 4개, case2는 공백이 없게 된다
  - 또한 저장 길이를 따로 바이트로 관리하는 것을 확인할 수 있다.

## CHAR 타입, VARCHAR타입 선정 기준

### 일반적으로 알려진 기준
- 고정된 길이 -> CHAR, 그 외의 경우 -> VARCHAR
- 별로 적합한 기준이 아니다
- 이 기준대로라면 주민등록번호의 경우에 CHAR(13)을 선택해야 한다
- 하지만 실제로는 VARCHAR(13)나 CHAR(13)나 거의 차이가 없다. (길이 관리를 위한 1바이트 크기 증가가 있다고 하더라도)
- 따라서 고정된 길이에 CHAR를 사용해야 한다는 것도 적합하지 않고, 실제로는 CHAR는 필요없이 VARCHAR만을 사용 해도 된다는 말 처럼 될 수도 있는데 이는 사실이 아니다

### 생각해보기
- CHAR의 공간 낭비가 심한 경우
  - 저장되는 문자열의 최소 최대 길이 가변 폭이 클 때 (ex 1 ~ 100)
- 공간 낭비가 크지 않을 떄
  - 저장되는 문자열의 최소 최대 길이 가변 폭이 작을 때 (ex 90 ~ 100)
- CHAR타입을 선택해도 빈 공간 할당을 통한 낭비가 심하지 않을 때가 있다는 것을 기억하자
- 그렇다면 CHAR의 **빈 공간 할당을 통해서 이득이 되는 경우**는 어떤 때 일까

### VARCHAR타입으로 선언된 칼럼 값의 길이 변경시 작동하는 원리

![image](https://github.com/user-attachments/assets/b069770e-a2e4-495d-bc8a-d0f0d9ad3c39)

- fd2칼럼이 ABCD로 인서트 된 후에 ABCED로 업데이트 된다면
- mysql서버는 레코드의 길이가 바뀌었기 때문에 원래 레코드가 저장되어 있던 위치에 인플레이스로 업데이트 할 수 없다는 것을 알아낸다.
- 따라서 전체 15바이트 레코드를 저장할 수 있는 공간을 찾아야 한다
- 여기서는 다행히 데이터 페이지가 거의 비어있어서 저장할 수 있는 공간을 어렵지 않게 찾았다.
- 변경이 계속 일어난다면 16kb 데이터 페이지에서 레코드 한 건을 저장할 수 있는 공간을 찾기 어렵게 된다.
- 어느 순간에는 빈 공간을 찾을 수 없게 되고, 페이지 레코드들을 다시 컴팩션 하는 작업을 한 후에야 저장할 수 있는 공간을 찾게 된다.
- ABCD가 ABCED로 업데이트 되기 위한 공간을 확보해두었던 CHAR였다면? 위와 같은 복잡한 과정이 일어나지 않게 된다 (레코드의 위치를 옮겨야 하는 가능성을 낮출 수 있음)
- 페이지의 프래그멘테이션을 최소화 해주는 효과를 가짐

### 결론

- VARCHAR보다 CHAR를 선택해야 하는 경우
  - 값의 가변 길이 범위 폭이 좁고
  - 자주 변경되는 경우 (특히 인덱스 된 칼럼인 경우)
    - 위와 같은 경우에 VARCHAR를 사용하게 된다면
    - 데이터 페이지 내부의 조각화 현상 증가
    - CHAR보다 공간 효율 떨어짐
    - 내부적으로 빈번한 페이지 조각 모음 작업 필요해짐 -> 성능 저하
