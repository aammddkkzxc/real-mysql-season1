#  COUNT(*) & COUNT(DISTINCT) 튜닝

## SELECT COUNT(*), SELECT *

- SELECT COUNT(*) 이 SELECT * 보다 가볍게 처리 될 것이라고 기대하는 경우가 많으나 그렇지 않다.
- 일반적으로 서비스 구현 요건 상 SELECT * 는 LIMIT 구와 함께 사용되지만 SELECT COUNT(*)는 그렇지 않다.
  - 설령 SELECT COUNT(*) 가 LIMIT구와 함께 사용되더라도 아무 의미가 없다
  - LIMIT구 -> 반환되는 행수를 제한하는 기능. SELECT COUNT(*)는 하나의 결과 값만 반환함
- 따라서 SELECT COUNT(*) 이 SELECT * 보다 부하가 훨씬 크고 시간이 많이 걸리는 경우가 많다.
- 밑에서 더 자세한 설명과 함께 알아보자

<br>

### 두개 쿼리 작동방식 예시

```
SELECT COUNT(*)
WHERE ix_fd = 'A' AND non_ix_fd = 'B';
-------------------------------
SELECT *
WHERE ix_fd = 'A' AND non_ix_fd = 'B';
```

- ix_fd 컬럼: 인덱스가 설정되어 있어, 데이터베이스는 이 컬럼을 기준으로 빠르게 검색할 수 있다.
- non_ix_fd 컬럼: 인덱스가 설정되어 있지 않기 때문에, 이 컬럼의 값을 확인하려면 데이터 파일에서 레코드를 읽어와야 한다.

#### SELECT COUNT(*) 동작 과정
- ix_fd = 'A' 조건을 만족하는 레코드를 인덱스를 사용하여 빠르게 찾는다.
- 해당 레코드들의 데이터 파일을 읽어와서 non_ix_fd = 'B' 조건을 확인
- 조건을 만족하는 레코드의 개수를 계산
- 결과로 개수(숫자)를 반환

#### SELECT * 동작 과정
- ix_fd = 'A' 조건을 만족하는 레코드를 인덱스를 사용하여 빠르게 찾는다.
- 해당 레코드들의 데이터 파일을 읽어와서 non_ix_fd = 'B' 조건을 확인
- 조건을 만족하는 레코드의 데이터를 모두 반환합니다.

#### 성능이 거의 동일한 이유
- 커버링 인덱스 미사용
  - 커버링 인덱스란, 쿼리에서 필요한 모든 데이터를 인덱스만으로 처리할 수 있는 경우를 의미
  - 하지만 여기서는 non_ix_fd 컬럼이 인덱스에 포함되어 있지 않기 때문에, 데이터 파일 접근이 필요
- 데이터 접근 방식 동일(I/O 작업)
  - 두 쿼리 모두 동일한 방식으로 데이터를 검색하고, 추가적인 필터링(non_ix_fd = 'B')을 수행
- 결과값의 바이트 수가 다르기 때문에 네트워크 사용량에서는 차이가 많이 날 수 있다.

#### LIMIT구 와 성능
- 앞서 말했듯이 서비스 구현 요건 상 SELECT * 는 LIMIT 구와 함께 사용되지만 SELECT COUNT(*)는 그렇지 않다.
- SELECT * 은 10건에서 20건만 줘야 하는 반면에 SELECT COUNTER는 WHERE 조건제를 일치하는 모든 레코드를 읽어야 전체 건수를 확인할 수 있다.
- 따라서 SELECT COUNT(*)의 쿼리 시간은 처리해야 하는 레코드 건수가 많다면 엄청 느려질 수 있다.

<br>

### COUNT(*) 튜닝
- 정확한 레코드 건수를 확인하는 가장 이상적인 성능 최적화는 커버링 인덱스 실행 계획으로 쿼리가 처리 되도록 하면 된다.
- 하지만 모든 COUNT ALL 쿼리를 커버링 인덱스로 최적화 할 수는 없
- 일반적으로 서비스에서는 COUNT ALL 쿼리라 하더라도 웨어 조건절에 많은 컬럼들의 비교 조건 사용된다.
- 이 모든 컬럼들을 인덱스에 추가하기에는 사실 성능적인 장점보다는 단점이 훨씬 더 많기 때문

```
1. Covering Index 예시 두가지

SELECT COUNT(*)
WHERE ix_fd1 = ? AND ix_fd2 = ?;
----------------------------------------
SELECT COUNT(ix_fd2)
WHERE ix_fd1 = ?;

2. Non-Covering Index 예시 두가지

SELECT COUNT(*)
WHERE ix_fd1 = ? AND non_ix_fd1 = ?;
-----------------------------------------
SELECT COUNT(non_ix_fd1)
WHERE ix_fd1 = ?;
```

### COUNT(*) 튜닝2
- 프로그램 로직을 변경하지 않고 하는 이상적인 커버링 인덱스 실행 계획 제외한 프로그램 로직을 변경하는 튜닝 방법들

<br>

- 쿼리 자체를 제거하는 방법
  - COUNT(*) 쿼리를 제거할 수 있는 케이스가 은근 있다.
  - 예를 들어서 예전에는 페이지 번호로 내비게이션을 할 수 있도록 기능을 제공하고 있었지만
  - 이 방식을 이전 혹은 이후 형태로 바꾼다
- 대략적인 레코드 건수를 사용하는 방법
  - 부분 레코드 건수 조회
    - 한 페이지에 20개의 레코드를 표시하는데 페이지 내비게이션을 위해서 10개까지 보여준다고 하는 경우
    ```
    SELECT COUNT(*) FROM (SELECT 1 FROM table LIMIT 200) z;
    ```  
    - 전체 레코드 건수는 필요치 않고 200건까지의 레코드가 있는지만 확인. 이를 위해서 limit 200건만 조회하는 서브 쿼리를 실행하고 그 결과 확인
    - 이렇게 쿼리를 실행하면 MySQL 서버는 최대 200건 이상을 조회하지 않고 만약 200건 미만인 경우에는 정확한 레코더 건수를 가져올 수 있게 된다.
    - 그리고 10페이지에서 20페이지까지를 조회할 때에는 Limit 400까지만 조회.
    - 이 방법은 뒤로 이동하면 할수록 쿼리의 성능은 느려지겠지만, 많은 사람들이 앞쪽 페이지 몇개만 조회하는 패턴이 일반적이기 때문에 효과적일 수 있다.
  - COUNT(*)를 먼저 실행하지 않고, 임의의 레코드 건수를 표시하는 방법
    - 처음 10개 페이지가 있는 것처럼 페이지 번호를 1부터 10번까지 표시.
    - 실제 사용자가 해당 페이지로 이동하면 그때 COUNT(*)가 아니라 SELECT * 를 실행해서 결과 존재 여부를 페이지 번호로 갱신.
    - 즉, 사용자가 페이지 내비게이션에서 7페이지를 클릭을 하면
    - SELECT * FROM table_name LIMIT 10 OFFSET 60 쿼리가 실행이 되게 되는데 결과가 10개 미만이면 7페이지를 마지막 페이지 번호로 표시.
    - 10개면 페이지 번호를 그대로 10까지 유지.
      - 이때 만약에 7페이지 데이터를 조회하는 쿼리 결과가 한건도 없다면 COUNT(*) 쿼리를 실행 -> 전체 레코드 건수를 확인하고 페이지 번호를 고친다.
      - 이 경우 COUNT(*) 쿼리를 실행하게 되지만 실제 레코드 건수는 많지 않기 때문에 성능적으로 큰 우려 사항이 되진 않을 것이다.
    - 구현이 쉽지는 않다고 한다
  - 통계 정보 활용
    - MySQL 서버에서는 Information Schema의 tables라는 뷰를 이용하면 특정 테이블의 전체 레코더 건수를 확인할 수가 있다.
      ```
      SELECT TABLE_ROWS AS rows
      FROM INFORMATION_SCHEMA.tables
      WHERE table_schema=? AND table_name=?;
      ```
    - 만약 COUNT(*)가 별도의 WHERE 조건 없이 테이블의 전체 레코드 건수를 조회하는 경우라면 이 통계 정보에서 테이블의 레코더 예측치를 조회해서 사용할 수 있다.
      - TABLE_ROWS는 통계 정보로, 정확한 레코드 수가 아니라 대략적인 값을 반환.
      - 이 값은 InnoDB와 같은 스토리지 엔진에서 테이블의 통계 정보를 기반으로 계산되며, 정확도가 떨어질 수 있다.
      - 특히, 테이블이 자주 업데이트되거나 DELETE/INSERT 작업이 많을 경우 오차가 커질 수 있습니다.
    - 만약 COUNT(*)가 WHERE 조건을 가진 경우에는 WHERE 조건들이 인덱스를 사용할 수 있도록 튜닝하고, 쿼리의 실행 계획에서 rows 클럼을 이용해서 그 예측된 값을 로우 값을 확인하는 방법도 생각해 볼 수 있다.
    - 조인이나 서브 쿼리가 있는 복잡한 쿼리에서는 정확도가 많이 떨어져서 사용이 어려울 수도 있지만, 그렇지 않은 경우에는 적절히 인덱스만 활용한다면 꽤 근접한 건수를 가져올 수 있다.
    - 물론 실행 계획의 로우스 컬럼 값은 COUNT(*) 보다는 정확도가 많이 떨어질 수 있지만, 많은 레코드 건수를 카운트해야 하는 경우에는 매우 빠르고 자원 효율적으로 건수를 확인할 수가 있다.
      - 심화 내용..
      - 통계 방법과 이전 페이지 보정을 이용하는 방법 까지 같이 사용한다면 더 좋은 방법이 될 수 있다..

### COUNT(*) 튜닝3
- 제거 하면 좋은 경우
  - WHERE 조건이 없는 COUNT(*)
  - WHERE 조건에 일치하는 레코드 건수가 많은 COUNT(*)
  - 제거할 수 없다면 앞서 살펴보았던 통계 정보를 이용하거나 예측건수를 이용해서 페이징을 구현하는 방법 고
- 인덱스를 활용해서 최적화 하면 좋은 경우
  - 정확한 COUNT(*)가 필요한 경우
  - COUNT(*) 대상 건수가 소량인 경우
  - WHERE 조건이 모 인덱스로 처리될 수 있는 커버링 인덱스 최적화 가능한 경우
  - 일반적인 OLTP 쿼리에서는 몇만 건 이내에의 건수 확인 정도는 인덱스 튜닝으로 최적화를 해 볼 수 있지만 그 이상인 경우에는 빠른 성능이 보장되기 어렵다. -> 다른 방법
    

<br>

## COUNT(*) & COUNT(DISTINCT expr)
- COUNT(*) 은 레코드 건수만 확인
- COUNT(DISTINCT expr)은 임시 테이블로 중복 제거 후 건수 확인. expr -> 표현식, 값 또는 칼럼

![image](https://github.com/user-attachments/assets/234c8ade-8f39-4078-b0ae-290d1a121582)

1. 서버가 임시 테이블 생성
2. where조건절에 일치하는 레코드 임시 테이블에 저장해야 함. 이 때 임시 테이블에 중복되는 레코드인지 점검 후 저장
3. 모두 저장 완료 후 임시 테이블의 레코드 수 집계

- 따라서 내부적으로 레코드 건 마다 셀렉트와 인서트를 한번씩 더 수행하게 된다는 것을 알 수 있다.
- 레코드 건수가 매우 많아지게 되면 추가적으로 너무 큰 임시테이블이 메모리에 상주하는 것을 막기 위해 임시 테이블을 디스크로 다시 옮겨 저장하는 작업도 수행된다.
- orm이 자동적으로 COUNT(DISTINCT id) 로 실행하는 경우가 있기 때문에 orm사용 어떤 쿼리가 나가는지 정확히 확인하는 것이 필요하다.
  - 자동적으로 DISTINCT가 추가되는 경우 필요한지 고민해 볼 필요가 있다.
